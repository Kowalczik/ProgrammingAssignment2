## Modified from the example code, but alters from MEAN to SOLVE
## SOLVE requires for a matrix to be square in order to have an 
## inverse, so this function will check for prereqs before proceeding 
## and caching

makeCacheMatrix <- function(x = matrix()) {
  # Checks the iput type against a matrix
  if (det(x) == 0){
    message("The determinant is 0; the matrix is singular!")
    return(NULL)
  }
  if (ncol(x) == nrow(x)){
    #ensures the matrix is square
    x <- matrix(as.numeric(x), ncol(x))
    # forces the matrix to be numeric
    memMatrix <- NULL
    set <- function(y)
    {
      x <<- y
      memMatrix <<- NULL
    }
    tic <- Sys.time()
    message("Creating Cache")
    get <- function() x
    setMatrix <- function(solve) memMatrix <<- solve
    #does the work
    getMatrix <- function() memMatrix
    #does the recall
    toc <- Sys.time() - tic
    message(paste("Completed computations in ", toc, " seconds"))
    return(list(set = set, get = get, setMatrix = setMatrix, getMatrix = getMatrix))
  }
  else{
    message("Rows and Columns did not match, matrix is non-invertible")
    return(NULL)}
}


## Modified from the example code
## It takes the list generated by the makeCacheMatrix and parses by name 

cacheSolve <- function(x, ...) {
  memMatrix = x$getMatrix()
  #Retrieve a matrix
  if(!is.null(memMatrix)) {
    message("Getting cached data")
    # if matrix was cached retrieves that and exits function
    return(memMatrix)
  }
  dataMatrix.data <- x$get()
  memMatrix <- solve(dataMatrix.data, ...)
  x$setMatrix(memMatrix)
  #if it was not cached it will solve it and set it to the cache via
  # the list function
  return(memMatrix)
}

##JTK
##21/06/15